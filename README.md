# overthrust-tests - P-Threads Implementation

About Implementation:

The base C code was generated by DEVITO [Version](https://github.com/speglich/devito/commit/ac2b8f60ee8b9faa39b935d0f0dd40c6a9842997)

The only edited code was the Forward C and the code is available in `C_DEVITO/devito-jitcache-uid4061/33a343a98d592a0c440d55b2a919ebb69851480f.c`

The edited code adds:

* Necessary Headers at beginning of the code (l: 13)

```c
#include "pthread.h"
#include "semaphore.h"
#include "stdio.h"
#include "unistd.h"
#include "fcntl.h"
```

* Writter Function, consumes all timesteps created by the main threads (l: 38)

```c
struct writter_struct {
    int begin;
    int end;
    int fdes;
    void* vec;
} ;

sem_t mutex;
int to_write = 0;

void *Writter(void* arguments){

  struct writter_struct *args = (struct writter_struct *) arguments;

  struct dataobj *restrict u_vec = (struct dataobj *restrict) args->vec;

  float (*restrict u)[u_vec->size[1]][u_vec->size[2]][u_vec->size[3]] __attribute__ ((aligned (64))) = (float (*)[u_vec->size[1]][u_vec->size[2]][u_vec->size[3]]) u_vec->data;

  unsigned long u_size = u_vec->size[1]*u_vec->size[2]*u_vec->size[3];

  int f = args->fdes;

  int begin = args->begin;
  int end = args->end + 1;

  int pos_write = begin;
  int len = 0;

  while(pos_write != end) {

    sem_wait(&mutex);
    len = to_write;
    sem_post(&mutex);

    int end = pos_write + len;

    for(int i = pos_write; i < end; i++) {
      write(f, u[i%3], sizeof(float)*u_size);
      pos_write++;
      printf("Thread write %d\n", i);
    }

    sem_wait(&mutex);
    to_write -= len;
    sem_post(&mutex);

  }

  return 0;
}
```

* Open the scratch file and iniatilize writter all args (l: 106)

```c
 int file;

  if ((file = open("/scr01/test.data", O_WRONLY | O_CREAT | O_TRUNC,
      S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
  {
      perror("Cannot open output file\n"); exit(1);
  }

  struct writter_struct args;
  args.vec = (void *) u_vec;
  args.fdes = file;
  args.begin = time_m;
  args.end = time_M;

  sem_init(&mutex, 0, 1);

  pthread_t thread;
  int iret1 = pthread_create(&thread, NULL, Writter, (void *) &args);
```
** YOU SHOULD CHANGE THE PATH TO A VALID DIRECTORY IN YOUR ENVIRONMENT **

* Timesteps are produced in order. So when we start a new timestep we increase the counter to_write (more one time step was produced). This counter can't reach the size of buffer of time_steps once we will destroy not written time steps.  (l: 70)

```c
    int busy = 1;
    while(busy)
    {
      if(to_write < 2) {
        sem_wait(&mutex);
        to_write++;
        sem_post(&mutex);
        busy = 0;
      } else {
        sleep(0.1);
      }
    }
```

* Wait until write the write finishes.... And after writing all timesteps, close the file. (l 299)
```c
 /* Wait until completion */
    {....
    pthread_join(thread, NULL);
    close(file);
  }
  int last_pos = time_M % 3;
  write(file, u[last_pos], u_size);
  close (file);
```

Usage:

```
make
```

This should run all the experiments.
